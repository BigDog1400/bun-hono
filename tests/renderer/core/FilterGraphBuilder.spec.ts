// tests/renderer/core/FilterGraphBuilder.spec.ts
import { FilterGraphBuilder } from '../../../src/renderer/core/FilterGraphBuilder';
import type { CanonicalTimeline } from '../../../src/renderer/core/CanonicalTimeline';
import type { RendererOptions } from '../../../src/renderer/types';
import { LayoutV1, LayoutDocumentSchema } from '../../../src/renderer/schema/layout-v1';

describe('FilterGraphBuilder', () => {
  let builder: FilterGraphBuilder;
  let mockTimeline: CanonicalTimeline;
  let mockOptions: RendererOptions;
  let mockLayout: LayoutV1;

  beforeEach(() => {
    // Basic valid layout for canvas dimensions
    mockLayout = LayoutDocumentSchema.parse({
      spec: 'layout/v1',
      canvas: { w: 1920, h: 1080, fps: 30 },
      blocks: [{ visuals: [{ kind: 'colour', src: 'black' }] }], // Minimal valid block
    });
    mockTimeline = { clips: [], duration: 10, canvas: mockLayout.canvas } as CanonicalTimeline;
    mockOptions = { outputDir: 'test_output', canvas: mockLayout.canvas };

    builder = new FilterGraphBuilder(mockTimeline, mockOptions, mockLayout);
  });

  describe('Input Management', () => {
    it('should add input and store mapping', () => {
      const inputIndex = builder.addInput('path/to/video.mp4', 'clip1');
      expect(inputIndex).toBe(0);
      expect(builder.getInputFilePaths()).toEqual(['-i "path/to/video.mp4"']);
    });

    it('should return correct input string for index', () => {
      builder.addInput('video1.mp4', 'c1');
      builder.addInput('image.png', 'c2');
      expect(builder.getInputStringForIndex(0)).toBe('0');
      expect(builder.getInputStringForIndex(1)).toBe('1');
    });
  });

  describe('Stream Label Management', () => {
    it('should generate unique stream labels', () => {
      const label1 = builder.getUniqueStreamLabel('v');
      const label2 = builder.getUniqueStreamLabel('v');
      const labelA1 = builder.getUniqueStreamLabel('a');
      expect(label1).toBe('[v1]');
      expect(label2).toBe('[v2]');
      expect(labelA1).toBe('[a1]');
    });

    it('should update and get clip stream output labels', () => {
      builder.updateClipStreamOutput('clip1', 'video', '[v_clip1_effected]');
      builder.updateClipStreamOutput('clip1', 'audio', '[a_clip1_effected]');

      expect(builder.getClipStreamOutput('clip1', 'video')).toBe('[v_clip1_effected]');
      expect(builder.getClipStreamOutput('clip1', 'audio')).toBe('[a_clip1_effected]');
      expect(builder.getClipStreamOutput('clip2', 'video')).toBeUndefined();
    });
  });

  describe('Filter Operations', () => {
    it('should add a filter segment', () => {
      builder.addFilterSegment('[0:v]scale=1280:720[scaled_v]');
      const { complexFilter } = builder.build();
      expect(complexFilter).toContain('[0:v]scale=1280:720[scaled_v]');
    });

    it('should correctly build an overlayVideo filter', () => {
      const base = '[base_v]';
      const overlay = '[overlay_v]';
      const outStream = builder.overlayVideo(base, overlay, 100, 50);
      expect(outStream).toBe('[v1]'); // First video stream generated by getUniqueStreamLabel('v')
      const { complexFilter } = builder.build();
      expect(complexFilter).toBe(`-filter_complex "${base}${overlay}overlay=100:50[v1]"`);
    });

    it('should correctly build an overlayVideo filter with shortest=1', () => {
      const outStream = builder.overlayVideo('[b]', '[o]', 0, 0, true);
      expect(outStream).toBe('[v1]');
      const { complexFilter } = builder.build();
      expect(complexFilter).toBe(`-filter_complex "[b][o]overlay=0:0:shortest=1[v1]"`);
    });

    it('should correctly build an amix filter for multiple audio streams', () => {
      const audio1 = '[a_stream1]';
      const audio2 = '[a_stream2]';
      const outStream = builder.mixAudio([audio1, audio2], 0.5);
      expect(outStream).toBe('[a1]'); // First audio stream generated
      const { complexFilter } = builder.build();
      expect(complexFilter).toBe(`-filter_complex "${audio1}${audio2}amix=inputs=2:duration=longest:dropout_transition=0.5[a1]"`);
    });

    it('should return single stream if only one audio stream for mixAudio', () => {
      const audio1 = '[a_single]';
      const outStream = builder.mixAudio([audio1]);
      expect(outStream).toBe('[a_single]');
      const { complexFilter } = builder.build();
      expect(complexFilter).toBe(''); // No filter added
    });
     it('should throw error if mixAudio is called with no streams', () => {
      expect(() => builder.mixAudio([])).toThrow("No audio streams provided to mixAudio.");
    });
  });

  describe('Build Command', () => {
    it('should build a command with inputs, complex filter, and maps', () => {
      builder.addInput('vid.mp4', 'c1');
      builder.addFilterSegment('[0:v]dummyfilter[fv]');
      builder.addFilterSegment('[0:a]adummyfilter[fa]');
      builder.setFinalVideoOutput('[fv]');
      builder.setFinalAudioOutput('[fa]');

      const command = builder.build();

      expect(command.inputs).toEqual(['-i "vid.mp4"']);
      expect(command.complexFilter).toBe('-filter_complex "[0:v]dummyfilter[fv]; [0:a]adummyfilter[fa]"');
      expect(command.maps).toEqual(['-map "[fv]"', '-map "[fa]"']);
    });

    it('should build command without maps if final outputs are not set', () => {
        const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});
        const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => {});

        builder.addInput('vid.mp4', 'c1');
        builder.addFilterSegment('[0:v]dummyfilter[fv]');
        const command = builder.build();

        expect(command.maps).toEqual([]);
        expect(consoleWarnSpy).toHaveBeenCalledWith(expect.stringContaining("No final video output stream was set"));
        expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining("No final audio output stream was set"));

        consoleWarnSpy.mockRestore();
        consoleLogSpy.mockRestore();
    });
     it('should build command without complex filter if no segments added', () => {
      builder.addInput('vid.mp4', 'c1');
      builder.setFinalVideoOutput('[0:v]'); // Direct mapping
      const command = builder.build();
      expect(command.complexFilter).toBe('');
      expect(command.maps).toEqual(['-map "[0:v]"']);
    });
  });

  describe('getCanvasDimensions', () => {
    it('should return canvas dimensions and background from layout', () => {
      const dims = builder.getCanvasDimensions();
      expect(dims.w).toBe(1920);
      expect(dims.h).toBe(1080);
      expect(dims.fps).toBe(30);
      expect(dims.background).toBeUndefined(); // Default layout has no canvas background

      const layoutWithBg = LayoutDocumentSchema.parse({
        spec: 'layout/v1',
        canvas: { w: 1280, h: 720, fps: 25, background: { kind: 'colour', src: 'blue'} },
        blocks: [{ visuals: [{ kind: 'colour', src: 'black' }] }],
      });
      const builderWithBg = new FilterGraphBuilder({} as any, {} as any, layoutWithBg);
      const dimsWithBg = builderWithBg.getCanvasDimensions();
      expect(dimsWithBg.background).toEqual({ kind: 'colour', src: 'blue'});
    });
  });
});
