import { SourceRenderer } from '../../types';
import { FilterGraphBuilder } from '../../core/FilterGraphBuilder';
import { CTClip, CTSource } from '../../core/CanonicalTimeline';
import { sourceRegistry } from '../../core/PluginRegistry';

// Helper to get canvas dimensions (same as in video.ts/image.ts)
const getCanvasDimensions = (builder: FilterGraphBuilder) => {
  const options = (builder as any).options || {};
  return {
    width: options.canvasWidth || 1920,
    height: options.canvasHeight || 1080,
    fps: options.fps || 30,
  };
};

class ColourSourceRenderer implements SourceRenderer {
  kind: string = 'colour'; // Or 'color' - ensure consistency with CTSource.kind

  async probe(source: CTSource): Promise<{ duration?: number }> {
    // Colours don't have an intrinsic duration.
    return { duration: Infinity };
  }

  addInputs(builder: FilterGraphBuilder, clip: CTClip, source: CTSource): void {
    // Colours are generated by filters, no file input needed.
    // This method is a no-op.
  }

  getFilter(
    builder: FilterGraphBuilder,
    clip: CTClip,
    source: CTSource // CTSource.src here would be the color string e.g. '#RRGGBBAA' or 'red'
  ): { video?: string; audio?: string } {
    const canvas = getCanvasDimensions(builder);
    const clipDuration = clip.duration;

    if (!clipDuration || clipDuration <= 0) {
      console.warn(`ColourSourceRenderer: Clip ${clip.id} has invalid duration (${clipDuration}). Cannot generate filter.`);
      return {};
    }

    if (!source.resolvedPath && !source.url) { // For color, src/url might hold the color string
        console.warn(`ColourSourceRenderer: Source ${source.id} for clip ${clip.id} has no color information in resolvedPath/url. Defaulting to black.`);
    }
    const colorValue = source.resolvedPath || source.url || 'black'; // Expect color string in resolvedPath or url

    const videoStreamName = builder.getUniqueStreamLabel(`v_${clip.id}`);

    // Generate using `color` filter.
    // `color=c=${colorValue}:s=${canvas.width}x${canvas.height}:d=${clipDuration}`
    // `format=rgba` is important for potential opacity changes later or if the color has alpha.
    // `lutalpha` for opacity if needed.
    let videoFilter = `color=c=${colorValue}:s=${canvas.width}x${canvas.height}:d=${clipDuration},format=rgba`;

    const opacity = typeof clip.opacity === 'number' ? clip.opacity : 1.0;
    if (opacity < 1.0) {
      // If the color itself has an alpha (e.g., from an RGBA string), multiplying is more complex.
      // FFmpeg's `color` filter might handle RGBA in `c` directly. If so, `lutalpha` will "stack" on that.
      // For simplicity, assuming `colorValue` is RGB and opacity is applied here.
      videoFilter += `,lutalpha=val=${opacity}`;
    }

    videoFilter += `[${videoStreamName}]`;
    builder.addFilter(videoFilter);

    // Colours don't produce audio.
    return { video: videoStreamName };
  }
}

sourceRegistry.register(new ColourSourceRenderer());
